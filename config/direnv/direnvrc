#!/usr/bin/env bash
# vim: syn=sh
# shellcheck disable=SC2181

if ! has log_error; then
  # Usage: log_error [<message> ...]
  #
  # Logs an error message. Acts like echo,
  # but wraps output in the standard direnv log format
  # (controlled by $DIRENV_LOG_FORMAT), and directs it
  # to stderr rather than stdout.
  #
  # Example:
  #
  #    log_error "Unable to find specified directory!"
  log_error() {
    local color_normal
    local color_error
    color_normal=$(tput sgr0)
    color_error=$(tput setaf 1)
    if [[ -n $DIRENV_LOG_FORMAT ]]; then
      local msg=$*
      # shellcheck disable=SC2059,1117
      printf "${color_error}${DIRENV_LOG_FORMAT}${color_normal}\n" "$msg" >&2
    fi
  }
fi


use_python() {
  local python_root="${HOME}/.pyenv/versions/$1"
  if [ $# -gt 0 ]; then shift; fi

  load_prefix "${python_root}"
  if [ -x "${python_root}/bin/python3" ]; then
    layout python "${python_root}/bin/python3" --no-site-packages "$@"
  else
    layout python "${python_root}/bin/python" --no-site-packages "$@"
  fi
}

use_ruby() {
  local version ruby_version
  ruby_version="${1:-}"

  if ! type chruby &>/dev/null; then
    if [ -e "${HOME}/.nix-profile/share/chruby/chruby.sh" ]; then
      . "${HOME}/.nix-profile/share/chruby/chruby.sh"
    elif [ -e "/usr/local/share/chruby/chruby.sh" ]; then
      . '/usr/local/share/chruby/chruby.sh'
    else
      log_error "Please install chruby to use the 'use ruby <version>' feature"
      return 1
    fi
  fi

  # If not given in ./.envrc, defer to the ./.ruby-version file
  if { read -r version <"${PWD}/.ruby-version"; } 2>/dev/null || [ -n "$version" ]; then
    if [ -n "$ruby_version" ] && [ "$ruby_version" != "$version" ]; then
      log_error "Ruby version specified in \`.envrc' is different from \`.ruby-version'. Preferring \`.envrc'"
    fi
  fi

  if [ -n "$ruby_version" ]; then
    chruby "$ruby_version"
    if [ $? -ne 0 ]; then return $?; fi
  elif [ -n "$version" ]; then
    chruby "$version"
    if [ $? -ne 0 ]; then return $?; fi
  else
    log_error "No ruby version found. Please add a valid ruby version to \`./.ruby-version'"
    return 1
  fi

  if [ -f "Gemfile" ] && has bundle; then
    if [ ! -f "Gemfile.lock" ] || [ ! -d "bin" ]; then
      bundle install --binstubs
      [ $? -eq 0 ] || return $?
    fi
    if [ -d "bin" ]; then
      path_add PATH "$(realpath 'bin')"
    fi
  fi
}

use_chef() {
  if has chef; then
    # Compliments the chef completion stuff already in the bash/zsh configs
    eval "$(chef shell-init "$(basename "$SHELL")" | grep -e '^export ')"
    export CHEF_ENV="dev"
  else
    log_error "Please install ChefDK to use 'use chef' feature"
    return 1
  fi
}

# Project-specific vim configurations
use_customized_vim() {
  local extravim
  extravim="$(find_up .vimrc)"
  if [ -n "$extravim" ] && [ "$extravim" != "${HOME}/.vimrc" ]; then
    echo "Adding vim configurations: ${extravim}"
    path_add EXTRA_VIM "$extravim"
  fi
}

use_java() {
  if [ ! -e "${HOME}/.jabba/jabba.sh" ]; then
    log_error 'Not found: jabba. Please install from https://github.com/shyiko/jabba and then run `direnv reload`'
    exit 1
  fi

  . "${HOME}/.jabba/jabba.sh"

  if [ -n "${1:-}" ]; then
    jabba use "${1}"
  elif [ -z "${1:-}" ] && [ -n "$(jabba alias default)" ]; then
    jabba use default
  else
    log_error 'No "default" java found. Please set it with `jabba alias default {version}`'
  fi
  hash -r

  # Not needed since direnv reverts it for us, so we're
  # unsetting it to reduce noise in the direnv diff
  unset JAVA_HOME_BEFORE_JABBA
}

use_kubectl() {
  # Ensure our main kubeconfig is in the mix. If not set, it is
  # anyway, so this makes it easier to shovel in other configs of
  # higher priority
  KUBECONFIG="${KUBECONFIG:-${HOME}/.kube/config}"

  local kube_dir kube_config context
  context="$1"
  kube_dir="$(pwd)/.direnv/kube"
  mkdir -p "$kube_dir"

  # This is the default config for the directory, where we'll modify
  # project-specific configs for kubernetes
  touch "${kube_dir}/config"
  path_add "KUBECONFIG" "${kube_dir}/config"

  # This must come last so we can make sure switching contexts with
  # direnv is simple and easy, leaning heavily on kubectl's overlay
  # feature for multiple kubeconfig files (where first definition of
  # something is the authoritative configuration)
  printf 'current-context: %s\n' "${context}" > "${kube_dir}/context"
  path_add "KUBECONFIG" "${kube_dir}/context"

  export KUBECONFIG
}
