#!/usr/bin/env bash
# vim: syn=sh
# shellcheck disable=SC2181

if ! has log_error; then
  # Usage: log_error [<message> ...]
  #
  # Logs an error message. Acts like echo,
  # but wraps output in the standard direnv log format
  # (controlled by $DIRENV_LOG_FORMAT), and directs it
  # to stderr rather than stdout.
  #
  # Example:
  #
  #    log_error "Unable to find specified directory!"
  log_error() {
    local color_normal
    local color_error
    color_normal=$(tput sgr0)
    color_error=$(tput setaf 1)
    if [[ -n $DIRENV_LOG_FORMAT ]]; then
      local msg=$*
      # shellcheck disable=SC2059,1117
      printf "${color_error}${DIRENV_LOG_FORMAT}${color_normal}\n" "$msg" >&2
    fi
  }
fi

NODE_VERSION_PREFIX="${NODE_VERSION_PREFIX-}"
NODE_VERSIONS="${NODE_VERSIONS-"${HOME}/.nodenv/versions"}"

PYTHON_VERSION_PREFIX="${PYTHON_VERSION_PREFIX-}"
PYTHON_VERSIONS="${PYTHON_VERSIONS-"${HOME}/.pyenv/versions"}"

# Usage: use python
# Loads Python version from a `.python-version` file.
#
# Usage: use python <version>
# Loads specified Python version.
#
# If you specify a partial Python version (i.e. `3.2`), a fuzzy match
# is performed and the highest matching version installed is selected.
#
# Environment Variables:
#
# - $PYTHON_VERSIONS (required)
#   You must specify a path to your installed Python versions via the `$PYTHON_VERSIONS` variable.
#
# - $PYTHON_VERSION_PREFIX (optional) [default="cpython-v"]
#   Overrides the default version prefix.
use_python() {
  local version="$1"
  local via=""
  local python_version_prefix=${PYTHON_VERSION_PREFIX-cpython-v}
  local python_wanted
  local python_prefix
  local reported

  if [ -z "$PYTHON_VERSIONS" ] || [ ! -d "$PYTHON_VERSIONS" ]; then
    log_error "You must specify a \$PYTHON_VERSIONS environment variable and the directory specified must exist!"
    return 1
  fi

  if [ -z "$version" ] && [ -f .python-version ]; then
    version=$(<.python-version)
    via=".python-version"
  fi

  if [ -z "$version" ]; then
    log_error "I do not know which Python version to load because one has not been specified!"
    return 1
  fi

  python_wanted="${python_version_prefix}${version}"
  python_prefix="$(
    # Look for matching python versions in $PYTHON_VERSIONS path
    # Strip possible "/" suffix from $PYTHON_VERSIONS, then use that to
    # Strip $PYTHON_VERSIONS/$PYTHON_VERSION_PREFIX prefix from line.
    # Sort by version: split by "." then reverse numeric sort for each piece of the version string
    # The first one is the highest
    find "$PYTHON_VERSIONS" -maxdepth 1 -mindepth 1 -type d -name "$python_wanted*" \
      | while IFS= read -r line; do echo "${line#${PYTHON_VERSIONS%/}/${python_version_prefix}}"; done \
      | sort -t . -k 1,1rn -k 2,2rn -k 3,3rn \
      | head -1
  )"

  python_prefix="${PYTHON_VERSIONS}/${python_version_prefix}${python_prefix}"

  if [ ! -d "$python_prefix" ]; then
    log_error "Unable to find Python version ($version) in ($PYTHON_VERSIONS)!"
    return 1
  fi

  if [ ! -x "${python_prefix}/bin/python" ]; then
    log_error "Unable to load Python binary (python) for version ($version) in ($PYTHON_VERSIONS)!"
    return 1
  fi

  load_prefix "$python_prefix"
  layout_python "${python_prefix}/bin/python"
  reported="$(python -c 'import platform as p; import sys; sys.stdout.write(p.python_version())')"

  if [ -z "$via" ]; then
    log_status "Successfully loaded Python $reported, from prefix ($(user_rel_path "$python_prefix"))"
  else
    log_status "Successfully loaded Python $reported (via $via), from prefix ($(user_rel_path "$python_prefix"))"
  fi
}

use_ruby() {
  local version ruby_version
  ruby_version="${1:-}"

  if ! type chruby &>/dev/null; then
    if [ -e "${HOME}/.nix-profile/share/chruby/chruby.sh" ]; then
      . "${HOME}/.nix-profile/share/chruby/chruby.sh"
    elif [ -e "/usr/local/share/chruby/chruby.sh" ]; then
      . '/usr/local/share/chruby/chruby.sh'
    else
      log_error "Please install chruby to use the 'use ruby <version>' feature"
      return 1
    fi
  fi

  # If not given in ./.envrc, defer to the ./.ruby-version file
  if { read -r version <"${PWD}/.ruby-version"; } 2>/dev/null || [ -n "$version" ]; then
    if [ -n "$ruby_version" ] && [ "$ruby_version" != "$version" ]; then
      log_error "Ruby version specified in \`.envrc' is different from \`.ruby-version'. Preferring \`.envrc'"
    fi
  fi

  if [ -n "$ruby_version" ]; then
    chruby "$ruby_version"
    if [ $? -ne 0 ]; then return $?; fi
  elif [ -n "$version" ]; then
    chruby "$version"
    if [ $? -ne 0 ]; then return $?; fi
  else
    log_error "No ruby version found. Please add a valid ruby version to \`./.ruby-version'"
    return 1
  fi

  layout_ruby
}

use_chef() {
  if has chef; then
    direnv_load chef shell-init "$(basename -- "$SHELL")"
    # Compliments the chef completion stuff already in the bash/zsh configs
    eval "$(chef shell-init "$(basename "$SHELL")" | grep -e '^export ')"
    export CHEF_ENV="dev"
  else
    log_error "Please install ChefDK to use the 'use chef' feature"
    return 1
  fi
}

# Project-specific vim configurations
use_customized_vim() {
  local extravim
  extravim="$(find_up .vimrc)"
  if [ -n "$extravim" ] && [ "$extravim" != "${HOME}/.vimrc" ]; then
    log_status "Adding vim configurations: ${extravim}"
    path_add EXTRA_VIM "$extravim"
  fi
}

use_java() {
  if [ ! -e "${HOME}/.jabba/jabba.sh" ]; then
    log_error 'Not found: jabba. Please install from https://github.com/shyiko/jabba and then run `direnv reload`'
    exit 1
  fi

  . "${HOME}/.jabba/jabba.sh"

  if [ -n "${1:-}" ]; then
    jabba use "${1}"
  elif [ -z "${1:-}" ] && [ -n "$(jabba alias default)" ]; then
    jabba use default
  else
    log_error 'No "default" java found. Please set it with `jabba alias default {version}`'
  fi

  if [ -x "$(expand_path ./mvnw)" ]; then
    mkdir -p "$(direnv_layout_dir)/bin"
    command ln -fs "$(expand_path ./mvnw)" "$(direnv_layout_dir)/bin/mvn"
    PATH_add "$(direnv_layout_dir)/bin"
  fi
  if [ -x "$(expand_path ./gradlew)" ]; then
    mkdir -p "$(direnv_layout_dir)/bin"
    command ln -fs "$(expand_path ./gradlew)" "$(direnv_layout_dir)/bin/gradle"
    PATH_add "$(direnv_layout_dir)/bin"
  fi

  hash -r

  # Not needed since direnv reverts it for us, so we're
  # unsetting it to reduce noise in the direnv diff
  unset JAVA_HOME_BEFORE_JABBA
}

use_kubectx() {
  # Ensure our main kubeconfig is in the mix. If not set, it is
  # anyway, so this makes it easier to shovel in other configs of
  # higher priority
  KUBECONFIG="${KUBECONFIG:-${HOME}/.kube/config}"

  local kube_dir kube_config context
  context="$1"
  kube_dir="$(direnv_layout_dir)/kube"
  mkdir -p "$kube_dir"

  # This is the default config for the directory, where we'll modify
  # project-specific configs for kubernetes
  touch "${kube_dir}/config"
  path_add "KUBECONFIG" "${kube_dir}/config"

  # This must come last so we can make sure switching contexts with
  # direnv is simple and easy, leaning heavily on kubectl's overlay
  # feature for multiple kubeconfig files (where first definition of
  # something is the authoritative configuration)
  printf 'current-context: %s\n' "${context}" > "${kube_dir}/context"
  path_add "KUBECONFIG" "${kube_dir}/context"

  export KUBECONFIG
}

use_terraform() {
  local version
  version="${1:-11}"
  mkdir -p "$(direnv_layout_dir)/bin"
  if [ -x "${HOME}/.bin/terraform${version}" ]; then
    command ln -fs "${HOME}/.bin/terraform${version}" "$(direnv_layout_dir)/bin/terraform"
  else
    log_error "No such version '${version}' of terraform (or no binary \`~/.bin/terraform${version}')"
  fi

  path_add "PATH" "$(direnv_layout_dir)/bin"
}

KUBECTL_VERSIONS="${KUBECTL_VERSIONS-${HOME}/.kubectl-versions}"

use_kubectl() {
  local version="$1"
  local via=''
  local kubectl_version_prefix='v'
  local kubectl_wanted kubectl_prefix reported

  if [ -z "${KUBECTL_VERSIONS}" ] || [ ! -d "${KUBECTL_VERSIONS}" ]; then
    log_error "You must specify a \$KUBECTL_VERSIONS environment variable and the directory specified must exist!"
    return 1
  fi

  if [ -z "$version" ]; then
    log_error "I do not know which Python version to load because one has not been specified!"
    return 1
  fi

  helm_wanted="${kubectl_version_prefix}${version}"
  helm_prefix="$(
    # Look for matching python versions in $KUBECTL_VERSIONS path
    # Strip possible "/" suffix from $KUBECTL_VERSIONS, then use that to
    # Strip $KUBECTL_VERSIONS/$kubectl_version_prefix prefix from line.
    # Sort by version: split by "." then reverse numeric sort for each piece of the version string
    # The first one is the highest
    find "$KUBECTL_VERSIONS" -maxdepth 1 -mindepth 1 -type d -name "$kubectl_wanted*" \
      | while IFS= read -r line; do echo "${line#${KUBECTL_VERSIONS%/}/${kubectl_version_prefix}}"; done \
      | sort -t . -k 1,1rn -k 2,2rn -k 3,3rn \
      | head -1
  )"
  reported="${kubectl_prefix}"
  helm_prefix="${KUBECTL_VERSIONS}/${kubectl_version_prefix}${kubectl_prefix}"

  if [ ! -d "$kubectl_prefix" ]; then
    log_error "Unable to load Kubernetes CLI binary (kubectl) for version (${version}) in (${KUBECTL_VERSIONS})!"
    return 1
  fi

  if [ "$reported" != "${version}" ]; then
    log_status "Resolved kubectl '${version}' -> '$reported'"
  fi
  PATH_add "$kubectl_prefix"
}

HELM_VERSIONS="${HELM_VERSIONS-${HOME}/.helm-versions}"

use_helm() {
  local version="$1"
  local via=''
  local helm_version_prefix='v'
  local helm_wanted helm_prefix reported

  if [ -z "${HELM_VERSIONS}" ] || [ ! -d "${HELM_VERSIONS}" ]; then
    log_error "You must specify a \$HELM_VERSIONS environment variable and the directory specified must exist!"
    return 1
  fi

  if [ -z "$version" ]; then
    log_error "I do not know which Python version to load because one has not been specified!"
    return 1
  fi

  helm_wanted="${helm_version_prefix}${version}"
  helm_prefix="$(
    # Look for matching python versions in $PYTHON_VERSIONS path
    # Strip possible "/" suffix from $PYTHON_VERSIONS, then use that to
    # Strip $PYTHON_VERSIONS/$PYTHON_VERSION_PREFIX prefix from line.
    # Sort by version: split by "." then reverse numeric sort for each piece of the version string
    # The first one is the highest
    find "$HELM_VERSIONS" -maxdepth 1 -mindepth 1 -type d -name "$helm_wanted*" \
      | while IFS= read -r line; do echo "${line#${HELM_VERSIONS%/}/${helm_version_prefix}}"; done \
      | sort -t . -k 1,1rn -k 2,2rn -k 3,3rn \
      | head -1
  )"
  reported="${helm_prefix}"
  helm_prefix="${HELM_VERSIONS}/${helm_version_prefix}${helm_prefix}"

  if [ ! -d "$helm_prefix" ]; then
    log_error "Unable to load Helm binary (helm) for version (${version}) in (${HELM_VERSIONS})!"
    return 1
  fi

  if [ "$reported" != "${version}" ]; then
    log_status "Resolved helm '${version}' -> '$reported'"
  fi
  PATH_add "$helm_prefix"
}
